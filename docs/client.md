在客户端的实现中，现在想要解决的问题是

1. 能够从多个客户端下载同一个文件。
1. 能够在下载文件的同时，接受多个客户端的request并且给别人传文件。

前提：1. 每个客户端都有一个监听端口，通过这个端口获得与不同客户端连接的socket。

下面的问题是，用一个socket与一个客户端通信是否足够

需要面对的一种情形是，我有文件的前50%，他有文件的后50%，此时其实可以我们相互传，那么这个时候，到底是使用一条tcp连接进行双向传输，还是使用两条tcp连接分别握手传输呢？

1. 讨论一下两条tcp连接的可行性
    1. 两条tcp连接的话，也就是说，一条连接是我主动向客户端请求文件得到的，另一条连接是客户端主动向我请求文件得到的
    1. 由于请求的时候会分配一个随机端口号，所以无论是我还是客户端都能够获得两个socket，然后将这两个socket分别用不同的方法处理即可
    1. 然后，这样的话，也就是说客户端需要有一个socket一直负责监听，一旦有请求（当然是别人向我请求文件），则产生一个发送文件的socket，放到发送文件的队列中
    1. 可以分为这三类线程程
        1. 监听线程：负责得到新连接的socket，并放到发送文件的socket队列中
        1. 发送文件线程：每一个线程维护一个发送文件的socket，这个socket里面的状态转换已经搞定啦
        1. 接受文件线程：同上，然后维护对不同主机请求文件的多个socket对应多个socket，状态转移也ok
    1. 实现上也似乎还可以
    1. 有一个问题
        1. 客户端的消息发送状态转移机制，是通过向对应的socket发送消息做到的
            1. 那么两个客户端之间有可能有两条tcp连接，有没有消息既会影响发送文件又会影响接收文件呢？
            1. 如果有的话，但是消息我只能发往其中一个socket，这就出现问题了。
            1. 看了一下，似乎并没有这样的消息
        1. 监听进程的accept()函数会阻塞，多进程能否在该函数阻塞的时候运行其他进程，而有新连接事件时触发这条进程的运行呢？（我觉得是有办法的）

1. 讨论一下客户端之间一条tcp连接的可行性
    1. 一条tcp连接的话，这条tcp连接是双向的通道，就要同时处理发送文件和接受文件
    1. 前文的两条连接的状态转移是很简单的，只是二元组的简单转移，现在两条tcp连接合为一条，也就是说，连接的状态是一个四元组，理论上四元组的状态转移也可以画出来，可能就是有点杂
    1. 今天颜彬讲到将这个状态转移变成二元组（我是否发你？，你是否发我？），现在想想这个做法的可行性
    1. 可以分为这两类进程
        1. 监听进程（同上）
        1. 客户端之间相连的进程：
            1. 该进程需要描述客户端之间的tcp连接的状态的转移
    1. 客户端之间相连的进程如何实现？
        1. 状态转移有点复杂，画了一下画不下去
    1. 问题：
        1. 客户端向另一个客户端请求文件的时候，需要先看看自己与该客户端有没有建立已有的连接？
            1. 如果不检查的话，就回到了两条tcp路线的情况